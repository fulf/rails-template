# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `lockbox` gem.
# Please instead update this file by running `bin/tapioca gem lockbox`.

# Ideally encryption and decryption would happen at the blob/service level.
# However, Active Storage < 6.1 only supports a single service (per environment).
# This means all attachments need to be encrypted or none of them,
# which is often not practical.
#
# Active Storage 6.1 adds support for multiple services, which changes this.
# We could have a Lockbox service:
#
# lockbox:
#   service: Lockbox
#   backend: local    # delegate to another service, like mirror service
#   key:     ...      # Lockbox options
#
# However, the checksum is computed *and stored on the blob*
# before the file is passed to the service.
# We don't want the MD5 checksum of the plaintext stored in the database.
#
# Instead, we encrypt and decrypt at the attachment level,
# and we define encryption settings at the model level.
#
# source://lockbox//lib/lockbox/aes_gcm.rb#1
module Lockbox
  extend ::Lockbox::Padding

  class << self
    # @raise [ArgumentError]
    #
    # source://lockbox//lib/lockbox.rb#66
    def attribute_key(table:, attribute:, master_key: T.unsafe(nil), encode: T.unsafe(nil)); end

    # Returns the value of attribute default_options.
    #
    # source://lockbox//lib/lockbox.rb#30
    def default_options; end

    # Sets the attribute default_options
    #
    # @param value the value to set the attribute default_options to.
    #
    # source://lockbox//lib/lockbox.rb#30
    def default_options=(_arg0); end

    # Returns the value of attribute encode_attributes.
    #
    # source://lockbox//lib/lockbox.rb#30
    def encode_attributes; end

    # Sets the attribute encode_attributes
    #
    # @param value the value to set the attribute encode_attributes to.
    #
    # source://lockbox//lib/lockbox.rb#30
    def encode_attributes=(_arg0); end

    # source://lockbox//lib/lockbox.rb#83
    def encrypts_action_text_body(**options); end

    # source://lockbox//lib/lockbox.rb#48
    def generate_key; end

    # source://lockbox//lib/lockbox.rb#52
    def generate_key_pair; end

    # source://lockbox//lib/lockbox.rb#36
    def master_key; end

    # Sets the attribute master_key
    #
    # @param value the value to set the attribute master_key to.
    #
    # source://lockbox//lib/lockbox.rb#31
    def master_key=(_arg0); end

    # source://lockbox//lib/lockbox.rb#40
    def migrate(relation, batch_size: T.unsafe(nil), restart: T.unsafe(nil)); end

    # source://lockbox//lib/lockbox.rb#79
    def new(**options); end

    # source://lockbox//lib/lockbox.rb#44
    def rotate(relation, attributes:, batch_size: T.unsafe(nil)); end

    # source://lockbox//lib/lockbox.rb#75
    def to_hex(str); end
  end
end

# source://lockbox//lib/lockbox/aes_gcm.rb#2
class Lockbox::AES_GCM
  # @raise [ArgumentError]
  # @return [AES_GCM] a new instance of AES_GCM
  #
  # source://lockbox//lib/lockbox/aes_gcm.rb#3
  def initialize(key); end

  # source://lockbox//lib/lockbox/aes_gcm.rb#28
  def decrypt(nonce, ciphertext, associated_data); end

  # source://lockbox//lib/lockbox/aes_gcm.rb#10
  def encrypt(nonce, message, associated_data); end

  # protect key
  #
  # source://lockbox//lib/lockbox/aes_gcm.rb#60
  def inspect; end

  # source://lockbox//lib/lockbox/aes_gcm.rb#55
  def nonce_bytes; end

  private

  # source://lockbox//lib/lockbox/aes_gcm.rb#66
  def auth_tag_bytes; end

  # source://lockbox//lib/lockbox/aes_gcm.rb#70
  def extract_auth_tag(bytes); end

  # @raise [DecryptionError]
  #
  # source://lockbox//lib/lockbox/aes_gcm.rb#75
  def fail_decryption; end
end

# source://lockbox//lib/lockbox/box.rb#2
class Lockbox::Box
  # @raise [ArgumentError]
  # @return [Box] a new instance of Box
  #
  # source://lockbox//lib/lockbox/box.rb#5
  def initialize(key: T.unsafe(nil), algorithm: T.unsafe(nil), encryption_key: T.unsafe(nil), decryption_key: T.unsafe(nil), padding: T.unsafe(nil), associated_data: T.unsafe(nil)); end

  # source://lockbox//lib/lockbox/box.rb#60
  def decrypt(ciphertext, associated_data: T.unsafe(nil)); end

  # source://lockbox//lib/lockbox/box.rb#40
  def encrypt(message, associated_data: T.unsafe(nil)); end

  # protect key for xsalsa20, xchacha20, and hybrid
  #
  # source://lockbox//lib/lockbox/box.rb#82
  def inspect; end

  private

  # source://lockbox//lib/lockbox/box.rb#92
  def extract_nonce(box, bytes); end

  # source://lockbox//lib/lockbox/box.rb#88
  def generate_nonce(box); end
end

# source://lockbox//lib/lockbox/box.rb#3
Lockbox::Box::NOT_SET = T.let(T.unsafe(nil), Object)

# source://lockbox//lib/lockbox/calculations.rb#2
module Lockbox::Calculations
  # source://lockbox//lib/lockbox/calculations.rb#3
  def pluck(*column_names); end
end

# source://lockbox//lib/lockbox.rb#22
class Lockbox::DecryptionError < ::Lockbox::Error; end

# source://lockbox//lib/lockbox/encryptor.rb#2
class Lockbox::Encryptor
  # @return [Encryptor] a new instance of Encryptor
  #
  # source://lockbox//lib/lockbox/encryptor.rb#3
  def initialize(**options); end

  # source://lockbox//lib/lockbox/encryptor.rb#22
  def decrypt(ciphertext, **options); end

  # source://lockbox//lib/lockbox/encryptor.rb#56
  def decrypt_io(io, **options); end

  # source://lockbox//lib/lockbox/encryptor.rb#62
  def decrypt_str(ciphertext, **options); end

  # source://lockbox//lib/lockbox/encryptor.rb#15
  def encrypt(message, **options); end

  # source://lockbox//lib/lockbox/encryptor.rb#50
  def encrypt_io(io, **options); end

  private

  # @raise [TypeError]
  #
  # source://lockbox//lib/lockbox/encryptor.rb#69
  def check_string(str); end

  # source://lockbox//lib/lockbox/encryptor.rb#76
  def copy_metadata(source, target); end
end

# source://lockbox//lib/lockbox.rb#21
class Lockbox::Error < ::StandardError; end

# source://lockbox//lib/lockbox/io.rb#2
class Lockbox::IO < ::StringIO
  # Returns the value of attribute content_type.
  #
  # source://lockbox//lib/lockbox/io.rb#3
  def content_type; end

  # Sets the attribute content_type
  #
  # @param value the value to set the attribute content_type to.
  #
  # source://lockbox//lib/lockbox/io.rb#3
  def content_type=(_arg0); end

  # private: do not use
  #
  # source://lockbox//lib/lockbox/io.rb#6
  def extracted_content_type; end

  # private: do not use
  #
  # source://lockbox//lib/lockbox/io.rb#6
  def extracted_content_type=(_arg0); end

  # Returns the value of attribute original_filename.
  #
  # source://lockbox//lib/lockbox/io.rb#3
  def original_filename; end

  # Sets the attribute original_filename
  #
  # @param value the value to set the attribute original_filename to.
  #
  # source://lockbox//lib/lockbox/io.rb#3
  def original_filename=(_arg0); end
end

# source://lockbox//lib/lockbox/key_generator.rb#2
class Lockbox::KeyGenerator
  # @return [KeyGenerator] a new instance of KeyGenerator
  #
  # source://lockbox//lib/lockbox/key_generator.rb#3
  def initialize(master_key); end

  # pattern ported from CipherSweet
  # https://ciphersweet.paragonie.com/internals/key-hierarchy
  #
  # @raise [ArgumentError]
  #
  # source://lockbox//lib/lockbox/key_generator.rb#9
  def attribute_key(table:, attribute:); end

  private

  # source://lockbox//lib/lockbox/key_generator.rb#19
  def hash_hmac(hash, ikm, salt); end

  # source://lockbox//lib/lockbox/key_generator.rb#23
  def hkdf(ikm, salt:, info:, length:, hash:); end
end

# source://lockbox//lib/lockbox/log_subscriber.rb#2
class Lockbox::LogSubscriber < ::ActiveSupport::LogSubscriber
  # source://lockbox//lib/lockbox/log_subscriber.rb#12
  def decrypt_file(event); end

  # source://lockbox//lib/lockbox/log_subscriber.rb#3
  def encrypt_file(event); end
end

# source://lockbox//lib/lockbox/migrator.rb#2
class Lockbox::Migrator
  # @return [Migrator] a new instance of Migrator
  #
  # source://lockbox//lib/lockbox/migrator.rb#3
  def initialize(relation, batch_size:); end

  # TODO add attributes option
  #
  # source://lockbox//lib/lockbox/migrator.rb#26
  def migrate(restart:); end

  # source://lockbox//lib/lockbox/migrator.rb#9
  def model; end

  # source://lockbox//lib/lockbox/migrator.rb#13
  def rotate(attributes:); end

  private

  # @return [Boolean]
  #
  # source://lockbox//lib/lockbox/migrator.rb#183
  def ar_relation?(relation); end

  # source://lockbox//lib/lockbox/migrator.rb#171
  def base_relation; end

  # source://lockbox//lib/lockbox/migrator.rb#99
  def each_batch(relation); end

  # there's a small chance for this process to read data,
  # another process to update the data, and
  # this process to write the now stale data
  # this time window can be reduced with smaller batch sizes
  # locking individual records could eliminate this
  # one option is: relation.in_batches { |batch| batch.lock }
  # which runs SELECT ... FOR UPDATE in Postgres
  #
  # source://lockbox//lib/lockbox/migrator.rb#126
  def migrate_records(records, fields:, blind_indexes:, restart:, rotate:); end

  # @return [Boolean]
  #
  # source://lockbox//lib/lockbox/migrator.rb#187
  def mongoid_relation?(relation); end

  # source://lockbox//lib/lockbox/migrator.rb#68
  def perform(fields:, blind_indexes: T.unsafe(nil), restart: T.unsafe(nil), rotate: T.unsafe(nil)); end

  # source://lockbox//lib/lockbox/migrator.rb#40
  def perform_attachments(attachments:, restart:); end

  # source://lockbox//lib/lockbox/migrator.rb#191
  def with_transaction; end
end

# source://lockbox//lib/lockbox/model.rb#2
module Lockbox::Model
  # @raise [ArgumentError]
  #
  # source://lockbox//lib/lockbox/model.rb#3
  def has_encrypted(*attributes, **options); end

  # source://lockbox//lib/lockbox/model.rb#671
  def lockbox_encrypts(*attributes, **options); end
end

# source://lockbox//lib/lockbox/model.rb#676
module Lockbox::Model::Attached
  # source://lockbox//lib/lockbox/model.rb#677
  def encrypts_attached(*attributes, **options); end
end

# source://lockbox//lib/lockbox/padding.rb#2
module Lockbox::Padding
  # source://lockbox//lib/lockbox/padding.rb#6
  def pad(str, **options); end

  # ISO/IEC 7816-4
  # same as Libsodium
  # https://libsodium.gitbook.io/doc/padding
  # apply prior to encryption
  # note: current implementation does not
  # try to minimize side channels
  #
  # @raise [ArgumentError]
  #
  # source://lockbox//lib/lockbox/padding.rb#20
  def pad!(str, size: T.unsafe(nil)); end

  # source://lockbox//lib/lockbox/padding.rb#10
  def unpad(str, **options); end

  # note: current implementation does not
  # try to minimize side channels
  #
  # @raise [ArgumentError]
  #
  # source://lockbox//lib/lockbox/padding.rb#38
  def unpad!(str, size: T.unsafe(nil)); end
end

# source://lockbox//lib/lockbox/padding.rb#3
Lockbox::Padding::PAD_FIRST_BYTE = T.let(T.unsafe(nil), String)

# source://lockbox//lib/lockbox/padding.rb#4
Lockbox::Padding::PAD_ZERO_BYTE = T.let(T.unsafe(nil), String)

# source://lockbox//lib/lockbox.rb#23
class Lockbox::PaddingError < ::Lockbox::Error; end

# source://lockbox//lib/lockbox/railtie.rb#2
class Lockbox::Railtie < ::Rails::Railtie; end

# source://lockbox//lib/lockbox/utils.rb#2
class Lockbox::Utils
  class << self
    # source://lockbox//lib/lockbox/utils.rb#3
    def build_box(context, options, table, attribute); end

    # @raise [Lockbox::Error]
    #
    # source://lockbox//lib/lockbox/utils.rb#61
    def decode_key(key, size: T.unsafe(nil), name: T.unsafe(nil)); end

    # source://lockbox//lib/lockbox/utils.rb#111
    def decrypt_result(record, name, options, result); end

    # source://lockbox//lib/lockbox/utils.rb#76
    def encrypt_attachable(record, name, attachable); end

    # @return [Boolean]
    #
    # source://lockbox//lib/lockbox/utils.rb#72
    def encrypted?(record, name); end

    # source://lockbox//lib/lockbox/utils.rb#57
    def encrypted_options(record, name); end

    # source://lockbox//lib/lockbox/utils.rb#117
    def rebuild_attachable(attachment); end
  end
end

# source://lockbox//lib/lockbox/version.rb#2
Lockbox::VERSION = T.let(T.unsafe(nil), String)
