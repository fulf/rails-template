# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `numo-narray` gem.
# Please instead update this file by running `bin/tapioca gem numo-narray`.

# source://numo-narray//lib/numo/narray/extra.rb#1
module Numo; end

class Numo::Bit < ::Numo::NArray
  def &(_arg0); end
  def [](*_arg0); end
  def []=(*_arg0); end
  def ^(_arg0); end
  def all?(*_arg0); end
  def allocate; end
  def any?(*_arg0); end
  def coerce_cast(_arg0); end
  def copy; end
  def count(*_arg0); end
  def count_0(*_arg0); end
  def count_1(*_arg0); end
  def count_false(*_arg0); end
  def count_true(*_arg0); end
  def each; end
  def each_with_index; end
  def eq(_arg0); end
  def extract; end
  def fill(_arg0); end
  def format(*_arg0); end
  def format_to_a(*_arg0); end
  def inspect; end
  def mask(_arg0); end
  def none?(*_arg0); end
  def store(_arg0); end
  def to_a; end
  def where; end
  def where2; end
  def |(_arg0); end
  def ~; end

  class << self
    def [](*_arg0); end
    def cast(_arg0); end
  end
end

Numo::Bit::CONTIGUOUS_STRIDE = T.let(T.unsafe(nil), Integer)
Numo::Bit::ELEMENT_BIT_SIZE = T.let(T.unsafe(nil), Integer)
Numo::Bit::ELEMENT_BYTE_SIZE = T.let(T.unsafe(nil), Float)
Numo::Bit::UPCAST = T.let(T.unsafe(nil), Hash)
Numo::Complex32 = Numo::SComplex
Numo::Complex64 = Numo::DComplex

class Numo::DComplex < ::Numo::NArray
  def *(_arg0); end
  def **(_arg0); end
  def +(_arg0); end
  def -(_arg0); end
  def -@; end
  def /(_arg0); end
  def [](*_arg0); end
  def []=(*_arg0); end
  def abs; end
  def allocate; end
  def angle; end
  def arg; end
  def ceil; end
  def close_to(_arg0); end
  def coerce_cast(_arg0); end
  def conj; end
  def conjugate; end
  def copysign(_arg0); end
  def cumprod(*_arg0); end
  def cumsum(*_arg0); end
  def each; end
  def each_with_index; end
  def eq(_arg0); end
  def extract; end
  def eye(*_arg0); end
  def fill(_arg0); end
  def floor; end
  def format(*_arg0); end
  def format_to_a(*_arg0); end
  def im; end
  def imag; end
  def imag=(_arg0); end
  def indgen(*_arg0); end
  def inspect; end
  def isfinite; end
  def isinf; end
  def isnan; end
  def isneginf; end
  def isposinf; end
  def kahan_sum(*_arg0); end
  def logseq(*_arg0); end
  def map; end
  def map_with_index; end
  def mean(*_arg0); end
  def mulsum(*_arg0); end
  def ne(_arg0); end
  def nearly_eq(_arg0); end
  def poly(*_arg0); end
  def pow(_arg0); end
  def prod(*_arg0); end
  def rand(*_arg0); end
  def rand_norm(*_arg0); end
  def real; end
  def real=(_arg0); end
  def reciprocal; end
  def rint; end
  def rms(*_arg0); end
  def round; end
  def seq(*_arg0); end
  def set_imag(_arg0); end
  def set_real(_arg0); end
  def sign; end
  def square; end
  def stddev(*_arg0); end
  def store(_arg0); end
  def sum(*_arg0); end
  def to_a; end
  def trunc; end
  def var(*_arg0); end

  class << self
    def [](*_arg0); end
    def cast(_arg0); end
  end
end

Numo::DComplex::CONTIGUOUS_STRIDE = T.let(T.unsafe(nil), Integer)
Numo::DComplex::ELEMENT_BIT_SIZE = T.let(T.unsafe(nil), Integer)
Numo::DComplex::ELEMENT_BYTE_SIZE = T.let(T.unsafe(nil), Integer)
Numo::DComplex::EPSILON = T.let(T.unsafe(nil), Float)
Numo::DComplex::MAX = T.let(T.unsafe(nil), Float)
Numo::DComplex::MIN = T.let(T.unsafe(nil), Float)

module Numo::DComplex::Math
  private

  def acos(_arg0); end
  def acosh(_arg0); end
  def asin(_arg0); end
  def asinh(_arg0); end
  def atan(_arg0); end
  def atanh(_arg0); end
  def cbrt(_arg0); end
  def cos(_arg0); end
  def cosh(_arg0); end
  def exp(_arg0); end
  def exp10(_arg0); end
  def exp2(_arg0); end
  def log(_arg0); end
  def log10(_arg0); end
  def log2(_arg0); end
  def sin(_arg0); end
  def sinc(_arg0); end
  def sinh(_arg0); end
  def sqrt(_arg0); end
  def tan(_arg0); end
  def tanh(_arg0); end

  class << self
    def acos(_arg0); end
    def acosh(_arg0); end
    def asin(_arg0); end
    def asinh(_arg0); end
    def atan(_arg0); end
    def atanh(_arg0); end
    def cbrt(_arg0); end
    def cos(_arg0); end
    def cosh(_arg0); end
    def exp(_arg0); end
    def exp10(_arg0); end
    def exp2(_arg0); end
    def log(_arg0); end
    def log10(_arg0); end
    def log2(_arg0); end
    def sin(_arg0); end
    def sinc(_arg0); end
    def sinh(_arg0); end
    def sqrt(_arg0); end
    def tan(_arg0); end
    def tanh(_arg0); end
  end
end

Numo::DComplex::UPCAST = T.let(T.unsafe(nil), Hash)

class Numo::DFloat < ::Numo::NArray
  def %(_arg0); end
  def *(_arg0); end
  def **(_arg0); end
  def +(_arg0); end
  def -(_arg0); end
  def -@; end
  def /(_arg0); end
  def <(_arg0); end
  def <=(_arg0); end
  def >(_arg0); end
  def >=(_arg0); end
  def [](*_arg0); end
  def []=(*_arg0); end
  def abs; end
  def allocate; end
  def argmax(*_arg0); end
  def argmin(*_arg0); end
  def ceil; end
  def clip(_arg0, _arg1); end
  def close_to(_arg0); end
  def coerce_cast(_arg0); end
  def conj; end
  def conjugate; end
  def copysign(_arg0); end
  def cumprod(*_arg0); end
  def cumsum(*_arg0); end
  def divmod(_arg0); end
  def each; end
  def each_with_index; end
  def eq(_arg0); end
  def extract; end
  def eye(*_arg0); end
  def fill(_arg0); end
  def floor; end
  def format(*_arg0); end
  def format_to_a(*_arg0); end
  def ge(_arg0); end
  def gt(_arg0); end
  def im; end
  def indgen(*_arg0); end
  def inspect; end
  def isfinite; end
  def isinf; end
  def isnan; end
  def isneginf; end
  def isposinf; end
  def kahan_sum(*_arg0); end
  def le(_arg0); end
  def logseq(*_arg0); end
  def lt(_arg0); end
  def map; end
  def map_with_index; end
  def max(*_arg0); end
  def max_index(*_arg0); end
  def mean(*_arg0); end
  def median(*_arg0); end
  def min(*_arg0); end
  def min_index(*_arg0); end
  def minmax(*_arg0); end
  def modf; end
  def mulsum(*_arg0); end
  def ne(_arg0); end
  def nearly_eq(_arg0); end
  def poly(*_arg0); end
  def pow(_arg0); end
  def prod(*_arg0); end
  def ptp(*_arg0); end
  def rand(*_arg0); end
  def rand_norm(*_arg0); end
  def reciprocal; end
  def rint; end
  def rms(*_arg0); end
  def round; end
  def seq(*_arg0); end
  def sign; end
  def signbit; end
  def sort(*_arg0); end
  def sort_index(*_arg0); end
  def square; end
  def stddev(*_arg0); end
  def store(_arg0); end
  def sum(*_arg0); end
  def to_a; end
  def trunc; end
  def var(*_arg0); end

  private

  def maximum(*_arg0); end
  def minimum(*_arg0); end

  class << self
    def [](*_arg0); end
    def cast(_arg0); end
    def maximum(*_arg0); end
    def minimum(*_arg0); end
  end
end

Numo::DFloat::CONTIGUOUS_STRIDE = T.let(T.unsafe(nil), Integer)
Numo::DFloat::ELEMENT_BIT_SIZE = T.let(T.unsafe(nil), Integer)
Numo::DFloat::ELEMENT_BYTE_SIZE = T.let(T.unsafe(nil), Integer)
Numo::DFloat::EPSILON = T.let(T.unsafe(nil), Float)
Numo::DFloat::MAX = T.let(T.unsafe(nil), Float)
Numo::DFloat::MIN = T.let(T.unsafe(nil), Float)

module Numo::DFloat::Math
  private

  def acos(_arg0); end
  def acosh(_arg0); end
  def asin(_arg0); end
  def asinh(_arg0); end
  def atan(_arg0); end
  def atan2(_arg0, _arg1); end
  def atanh(_arg0); end
  def cbrt(_arg0); end
  def cos(_arg0); end
  def cosh(_arg0); end
  def erf(_arg0); end
  def erfc(_arg0); end
  def exp(_arg0); end
  def exp10(_arg0); end
  def exp2(_arg0); end
  def expm1(_arg0); end
  def frexp(_arg0); end
  def hypot(_arg0, _arg1); end
  def ldexp(_arg0, _arg1); end
  def log(_arg0); end
  def log10(_arg0); end
  def log1p(_arg0); end
  def log2(_arg0); end
  def sin(_arg0); end
  def sinc(_arg0); end
  def sinh(_arg0); end
  def sqrt(_arg0); end
  def tan(_arg0); end
  def tanh(_arg0); end

  class << self
    def acos(_arg0); end
    def acosh(_arg0); end
    def asin(_arg0); end
    def asinh(_arg0); end
    def atan(_arg0); end
    def atan2(_arg0, _arg1); end
    def atanh(_arg0); end
    def cbrt(_arg0); end
    def cos(_arg0); end
    def cosh(_arg0); end
    def erf(_arg0); end
    def erfc(_arg0); end
    def exp(_arg0); end
    def exp10(_arg0); end
    def exp2(_arg0); end
    def expm1(_arg0); end
    def frexp(_arg0); end
    def hypot(_arg0, _arg1); end
    def ldexp(_arg0, _arg1); end
    def log(_arg0); end
    def log10(_arg0); end
    def log1p(_arg0); end
    def log2(_arg0); end
    def sin(_arg0); end
    def sinc(_arg0); end
    def sinh(_arg0); end
    def sqrt(_arg0); end
    def tan(_arg0); end
    def tanh(_arg0); end
  end
end

Numo::DFloat::UPCAST = T.let(T.unsafe(nil), Hash)
Numo::Float32 = Numo::SFloat
Numo::Float64 = Numo::DFloat

class Numo::Int16 < ::Numo::NArray
  def %(_arg0); end
  def &(_arg0); end
  def *(_arg0); end
  def **(_arg0); end
  def +(_arg0); end
  def -(_arg0); end
  def -@; end
  def /(_arg0); end
  def <(_arg0); end
  def <<(_arg0); end
  def <=(_arg0); end
  def >(_arg0); end
  def >=(_arg0); end
  def >>(_arg0); end
  def [](*_arg0); end
  def []=(*_arg0); end
  def ^(_arg0); end
  def abs; end
  def allocate; end
  def argmax(*_arg0); end
  def argmin(*_arg0); end
  def bincount(*_arg0); end
  def ceil; end
  def clip(_arg0, _arg1); end
  def close_to(_arg0); end
  def coerce_cast(_arg0); end
  def conj; end
  def conjugate; end
  def cumprod(*_arg0); end
  def cumsum(*_arg0); end
  def divmod(_arg0); end
  def each; end
  def each_with_index; end
  def eq(_arg0); end
  def extract; end
  def eye(*_arg0); end
  def fill(_arg0); end
  def floor; end
  def format(*_arg0); end
  def format_to_a(*_arg0); end
  def ge(_arg0); end
  def gt(_arg0); end
  def im; end
  def indgen(*_arg0); end
  def inspect; end
  def le(_arg0); end
  def lt(_arg0); end
  def map; end
  def map_with_index; end
  def max(*_arg0); end
  def max_index(*_arg0); end
  def median(*_arg0); end
  def min(*_arg0); end
  def min_index(*_arg0); end
  def minmax(*_arg0); end
  def mulsum(*_arg0); end
  def ne(_arg0); end
  def nearly_eq(_arg0); end
  def poly(*_arg0); end
  def pow(_arg0); end
  def prod(*_arg0); end
  def ptp(*_arg0); end
  def rand(*_arg0); end
  def reciprocal; end
  def rint; end
  def round; end
  def seq(*_arg0); end
  def sign; end
  def sort(*_arg0); end
  def sort_index(*_arg0); end
  def square; end
  def store(_arg0); end
  def sum(*_arg0); end
  def to_a; end
  def trunc; end
  def |(_arg0); end
  def ~; end

  private

  def maximum(*_arg0); end
  def minimum(*_arg0); end

  class << self
    def [](*_arg0); end
    def cast(_arg0); end
    def maximum(*_arg0); end
    def minimum(*_arg0); end
  end
end

Numo::Int16::CONTIGUOUS_STRIDE = T.let(T.unsafe(nil), Integer)
Numo::Int16::ELEMENT_BIT_SIZE = T.let(T.unsafe(nil), Integer)
Numo::Int16::ELEMENT_BYTE_SIZE = T.let(T.unsafe(nil), Integer)
Numo::Int16::MAX = T.let(T.unsafe(nil), Integer)
Numo::Int16::MIN = T.let(T.unsafe(nil), Integer)
Numo::Int16::UPCAST = T.let(T.unsafe(nil), Hash)

class Numo::Int32 < ::Numo::NArray
  def %(_arg0); end
  def &(_arg0); end
  def *(_arg0); end
  def **(_arg0); end
  def +(_arg0); end
  def -(_arg0); end
  def -@; end
  def /(_arg0); end
  def <(_arg0); end
  def <<(_arg0); end
  def <=(_arg0); end
  def >(_arg0); end
  def >=(_arg0); end
  def >>(_arg0); end
  def [](*_arg0); end
  def []=(*_arg0); end
  def ^(_arg0); end
  def abs; end
  def allocate; end
  def argmax(*_arg0); end
  def argmin(*_arg0); end
  def bincount(*_arg0); end
  def ceil; end
  def clip(_arg0, _arg1); end
  def close_to(_arg0); end
  def coerce_cast(_arg0); end
  def conj; end
  def conjugate; end
  def cumprod(*_arg0); end
  def cumsum(*_arg0); end
  def divmod(_arg0); end
  def each; end
  def each_with_index; end
  def eq(_arg0); end
  def extract; end
  def eye(*_arg0); end
  def fill(_arg0); end
  def floor; end
  def format(*_arg0); end
  def format_to_a(*_arg0); end
  def ge(_arg0); end
  def gt(_arg0); end
  def im; end
  def indgen(*_arg0); end
  def inspect; end
  def le(_arg0); end
  def lt(_arg0); end
  def map; end
  def map_with_index; end
  def max(*_arg0); end
  def max_index(*_arg0); end
  def median(*_arg0); end
  def min(*_arg0); end
  def min_index(*_arg0); end
  def minmax(*_arg0); end
  def mulsum(*_arg0); end
  def ne(_arg0); end
  def nearly_eq(_arg0); end
  def poly(*_arg0); end
  def pow(_arg0); end
  def prod(*_arg0); end
  def ptp(*_arg0); end
  def rand(*_arg0); end
  def reciprocal; end
  def rint; end
  def round; end
  def seq(*_arg0); end
  def sign; end
  def sort(*_arg0); end
  def sort_index(*_arg0); end
  def square; end
  def store(_arg0); end
  def sum(*_arg0); end
  def to_a; end
  def trunc; end
  def |(_arg0); end
  def ~; end

  private

  def maximum(*_arg0); end
  def minimum(*_arg0); end

  class << self
    def [](*_arg0); end
    def cast(_arg0); end
    def maximum(*_arg0); end
    def minimum(*_arg0); end
  end
end

Numo::Int32::CONTIGUOUS_STRIDE = T.let(T.unsafe(nil), Integer)
Numo::Int32::ELEMENT_BIT_SIZE = T.let(T.unsafe(nil), Integer)
Numo::Int32::ELEMENT_BYTE_SIZE = T.let(T.unsafe(nil), Integer)
Numo::Int32::MAX = T.let(T.unsafe(nil), Integer)
Numo::Int32::MIN = T.let(T.unsafe(nil), Integer)
Numo::Int32::UPCAST = T.let(T.unsafe(nil), Hash)

class Numo::Int64 < ::Numo::NArray
  def %(_arg0); end
  def &(_arg0); end
  def *(_arg0); end
  def **(_arg0); end
  def +(_arg0); end
  def -(_arg0); end
  def -@; end
  def /(_arg0); end
  def <(_arg0); end
  def <<(_arg0); end
  def <=(_arg0); end
  def >(_arg0); end
  def >=(_arg0); end
  def >>(_arg0); end
  def [](*_arg0); end
  def []=(*_arg0); end
  def ^(_arg0); end
  def abs; end
  def allocate; end
  def argmax(*_arg0); end
  def argmin(*_arg0); end
  def bincount(*_arg0); end
  def ceil; end
  def clip(_arg0, _arg1); end
  def close_to(_arg0); end
  def coerce_cast(_arg0); end
  def conj; end
  def conjugate; end
  def cumprod(*_arg0); end
  def cumsum(*_arg0); end
  def divmod(_arg0); end
  def each; end
  def each_with_index; end
  def eq(_arg0); end
  def extract; end
  def eye(*_arg0); end
  def fill(_arg0); end
  def floor; end
  def format(*_arg0); end
  def format_to_a(*_arg0); end
  def ge(_arg0); end
  def gt(_arg0); end
  def im; end
  def indgen(*_arg0); end
  def inspect; end
  def le(_arg0); end
  def lt(_arg0); end
  def map; end
  def map_with_index; end
  def max(*_arg0); end
  def max_index(*_arg0); end
  def median(*_arg0); end
  def min(*_arg0); end
  def min_index(*_arg0); end
  def minmax(*_arg0); end
  def mulsum(*_arg0); end
  def ne(_arg0); end
  def nearly_eq(_arg0); end
  def poly(*_arg0); end
  def pow(_arg0); end
  def prod(*_arg0); end
  def ptp(*_arg0); end
  def rand(*_arg0); end
  def reciprocal; end
  def rint; end
  def round; end
  def seq(*_arg0); end
  def sign; end
  def sort(*_arg0); end
  def sort_index(*_arg0); end
  def square; end
  def store(_arg0); end
  def sum(*_arg0); end
  def to_a; end
  def trunc; end
  def |(_arg0); end
  def ~; end

  private

  def maximum(*_arg0); end
  def minimum(*_arg0); end

  class << self
    def [](*_arg0); end
    def cast(_arg0); end
    def maximum(*_arg0); end
    def minimum(*_arg0); end
  end
end

Numo::Int64::CONTIGUOUS_STRIDE = T.let(T.unsafe(nil), Integer)
Numo::Int64::ELEMENT_BIT_SIZE = T.let(T.unsafe(nil), Integer)
Numo::Int64::ELEMENT_BYTE_SIZE = T.let(T.unsafe(nil), Integer)
Numo::Int64::MAX = T.let(T.unsafe(nil), Integer)
Numo::Int64::MIN = T.let(T.unsafe(nil), Integer)
Numo::Int64::UPCAST = T.let(T.unsafe(nil), Hash)

class Numo::Int8 < ::Numo::NArray
  def %(_arg0); end
  def &(_arg0); end
  def *(_arg0); end
  def **(_arg0); end
  def +(_arg0); end
  def -(_arg0); end
  def -@; end
  def /(_arg0); end
  def <(_arg0); end
  def <<(_arg0); end
  def <=(_arg0); end
  def >(_arg0); end
  def >=(_arg0); end
  def >>(_arg0); end
  def [](*_arg0); end
  def []=(*_arg0); end
  def ^(_arg0); end
  def abs; end
  def allocate; end
  def argmax(*_arg0); end
  def argmin(*_arg0); end
  def bincount(*_arg0); end
  def ceil; end
  def clip(_arg0, _arg1); end
  def close_to(_arg0); end
  def coerce_cast(_arg0); end
  def conj; end
  def conjugate; end
  def cumprod(*_arg0); end
  def cumsum(*_arg0); end
  def divmod(_arg0); end
  def each; end
  def each_with_index; end
  def eq(_arg0); end
  def extract; end
  def eye(*_arg0); end
  def fill(_arg0); end
  def floor; end
  def format(*_arg0); end
  def format_to_a(*_arg0); end
  def ge(_arg0); end
  def gt(_arg0); end
  def im; end
  def indgen(*_arg0); end
  def inspect; end
  def le(_arg0); end
  def lt(_arg0); end
  def map; end
  def map_with_index; end
  def max(*_arg0); end
  def max_index(*_arg0); end
  def median(*_arg0); end
  def min(*_arg0); end
  def min_index(*_arg0); end
  def minmax(*_arg0); end
  def mulsum(*_arg0); end
  def ne(_arg0); end
  def nearly_eq(_arg0); end
  def poly(*_arg0); end
  def pow(_arg0); end
  def prod(*_arg0); end
  def ptp(*_arg0); end
  def rand(*_arg0); end
  def reciprocal; end
  def rint; end
  def round; end
  def seq(*_arg0); end
  def sign; end
  def sort(*_arg0); end
  def sort_index(*_arg0); end
  def square; end
  def store(_arg0); end
  def sum(*_arg0); end
  def to_a; end
  def trunc; end
  def |(_arg0); end
  def ~; end

  private

  def maximum(*_arg0); end
  def minimum(*_arg0); end

  class << self
    def [](*_arg0); end
    def cast(_arg0); end
    def maximum(*_arg0); end
    def minimum(*_arg0); end
  end
end

Numo::Int8::CONTIGUOUS_STRIDE = T.let(T.unsafe(nil), Integer)
Numo::Int8::ELEMENT_BIT_SIZE = T.let(T.unsafe(nil), Integer)
Numo::Int8::ELEMENT_BYTE_SIZE = T.let(T.unsafe(nil), Integer)
Numo::Int8::MAX = T.let(T.unsafe(nil), Integer)
Numo::Int8::MIN = T.let(T.unsafe(nil), Integer)
Numo::Int8::UPCAST = T.let(T.unsafe(nil), Hash)

# source://numo-narray//lib/numo/narray/extra.rb#2
class Numo::NArray
  def initialize(*_arg0); end

  def ==(_arg0); end
  def []; end
  def []=; end

  # Append values to the end of an narray.
  #
  # @example
  #   a = Numo::DFloat[1, 2, 3]
  #   a.append([[4, 5, 6], [7, 8, 9]])
  #   # => Numo::DFloat#shape=[9]
  #   # [1, 2, 3, 4, 5, 6, 7, 8, 9]
  #
  #   a = Numo::DFloat[[1, 2, 3]]
  #   a.append([[4, 5, 6], [7, 8, 9]],axis:0)
  #   # => Numo::DFloat#shape=[3,3]
  #   # [[1, 2, 3],
  #   #  [4, 5, 6],
  #   #  [7, 8, 9]]
  #
  #   a = Numo::DFloat[[1, 2, 3], [4, 5, 6]]
  #   a.append([7, 8, 9], axis:0)
  #   # in `append': dimension mismatch (Numo::NArray::DimensionError)
  #
  # source://numo-narray//lib/numo/narray/extra.rb#240
  def append(other, axis: T.unsafe(nil)); end

  def at(*_arg0); end
  def byte_size; end
  def byte_swapped?; end
  def cast_to(_arg0); end
  def coerce(_arg0); end
  def column_major?; end

  # @example
  #   a = Numo::DFloat[[1, 2], [3, 4]]
  #   # => Numo::DFloat#shape=[2,2]
  #   # [[1, 2],
  #   #  [3, 4]]
  #
  #   b = Numo::DFloat[[5, 6]]
  #   # => Numo::DFloat#shape=[1,2]
  #   # [[5, 6]]
  #
  #   a.concatenate(b,axis:0)
  #   # => Numo::DFloat#shape=[3,2]
  #   # [[1, 2],
  #   #  [3, 4],
  #   #  [5, 6]]
  #
  #   a.concatenate(b.transpose, axis:1)
  #   # => Numo::DFloat#shape=[2,3]
  #   # [[1, 2, 5],
  #   #  [3, 4, 6]]
  #
  # source://numo-narray//lib/numo/narray/extra.rb#627
  def concatenate(*arrays, axis: T.unsafe(nil)); end

  def contiguous?; end
  def copy; end

  # under construction
  #
  # source://numo-narray//lib/numo/narray/extra.rb#1252
  def cov(y = T.unsafe(nil), ddof: T.unsafe(nil), fweights: T.unsafe(nil), aweights: T.unsafe(nil)); end

  def debug_info; end

  # Convert angles from degrees to radians.
  #
  # source://numo-narray//lib/numo/narray/extra.rb#30
  def deg2rad; end

  # @example
  #   a = Numo::DFloat[[1,2,3,4], [5,6,7,8], [9,10,11,12]]
  #   a.delete(1,0)
  #   # => Numo::DFloat(view)#shape=[2,4]
  #   # [[1, 2, 3, 4],
  #   #  [9, 10, 11, 12]]
  #
  #   a.delete((0..-1).step(2),1)
  #   # => Numo::DFloat(view)#shape=[3,2]
  #   # [[2, 4],
  #   #  [6, 8],
  #   #  [10, 12]]
  #
  #   a.delete([1,3,5])
  #   # => Numo::DFloat(view)#shape=[9]
  #   # [1, 3, 5, 7, 8, 9, 10, 11, 12]
  #
  # source://numo-narray//lib/numo/narray/extra.rb#275
  def delete(indice, axis = T.unsafe(nil)); end

  # Return a matrix whose diagonal is constructed by self along the last axis.
  #
  # source://numo-narray//lib/numo/narray/extra.rb#1073
  def diag(k = T.unsafe(nil)); end

  # Return the k-th diagonal indices.
  #
  # source://numo-narray//lib/numo/narray/extra.rb#1057
  def diag_indices(k = T.unsafe(nil)); end

  def diagonal(*_arg0); end

  # Calculate the n-th discrete difference along given axis.
  #
  # @example
  #   x = Numo::DFloat[1, 2, 4, 7, 0]
  #   # => Numo::DFloat#shape=[5]
  #   # [1, 2, 4, 7, 0]
  #
  #   x.diff
  #   # => Numo::DFloat#shape=[4]
  #   # [1, 2, 3, -7]
  #
  #   x.diff(2)
  #   # => Numo::DFloat#shape=[3]
  #   # [1, 1, -10]
  #
  #   x = Numo::DFloat[[1, 3, 6, 10], [0, 5, 6, 8]]
  #   # => Numo::DFloat#shape=[2,4]
  #   # [[1, 3, 6, 10],
  #   #  [0, 5, 6, 8]]
  #
  #   x.diff
  #   # => Numo::DFloat#shape=[2,3]
  #   # [[2, 3, 4],
  #   #  [5, 1, 2]]
  #
  #   x.diff(axis:0)
  #   # => Numo::DFloat#shape=[1,4]
  #   # [[-1, 2, 0, -2]]
  #
  # source://numo-narray//lib/numo/narray/extra.rb#951
  def diff(n = T.unsafe(nil), axis: T.unsafe(nil)); end

  # Dot product of two arrays.
  #
  # @param b [Numo::NArray]
  # @return [Numo::NArray] return dot product
  #
  # source://numo-narray//lib/numo/narray/extra.rb#1102
  def dot(b); end

  # source://numo-narray//lib/numo/narray/extra.rb#777
  def dsplit(indices_or_sections); end

  # Iterate over an axis
  #
  # @example
  #   > a = Numo::DFloat.new(2,2,2).seq
  #   > p a
  #   Numo::DFloat#shape=[2,2,2]
  #   [[[0, 1],
  #   [2, 3]],
  #   [[4, 5],
  #   [6, 7]]]
  #
  #   > a.each_over_axis{|i| p i}
  #   Numo::DFloat(view)#shape=[2,2]
  #   [[0, 1],
  #   [2, 3]]
  #   Numo::DFloat(view)#shape=[2,2]
  #   [[4, 5],
  #   [6, 7]]
  #
  #   > a.each_over_axis(1){|i| p i}
  #   Numo::DFloat(view)#shape=[2,2]
  #   [[0, 1],
  #   [4, 5]]
  #   Numo::DFloat(view)#shape=[2,2]
  #   [[2, 3],
  #   [6, 7]]
  #
  # source://numo-narray//lib/numo/narray/extra.rb#200
  def each_over_axis(axis = T.unsafe(nil)); end

  def empty?; end
  def expand_dims(_arg0); end
  def flatten; end

  # Flip each row in the left/right direction.
  # Same as `a[true, (-1..0).step(-1), ...]`.
  #
  # source://numo-narray//lib/numo/narray/extra.rb#36
  def fliplr; end

  # Flip each column in the up/down direction.
  # Same as `a[(-1..0).step(-1), ...]`.
  #
  # source://numo-narray//lib/numo/narray/extra.rb#42
  def flipud; end

  def fortran_contiguous?; end
  def free; end
  def host_order?; end

  # source://numo-narray//lib/numo/narray/extra.rb#773
  def hsplit(indices_or_sections); end

  def hton; end

  # Inner product of two arrays.
  # Same as `(a*b).sum(axis:-1)`.
  #
  # @param b [Numo::NArray]
  # @param axis [Integer] applied axis
  # @return [Numo::NArray] return (a*b).sum(axis:axis)
  #
  # source://numo-narray//lib/numo/narray/extra.rb#1141
  def inner(b, axis: T.unsafe(nil)); end

  def inplace; end
  def inplace!; end
  def inplace?; end

  # Insert values along the axis before the indices.
  #
  # @example
  #   a = Numo::DFloat[[1, 2], [3, 4]]
  #   a = Numo::Int32[[1, 1], [2, 2], [3, 3]]
  #
  #   a.insert(1,5)
  #   # => Numo::Int32#shape=[7]
  #   # [1, 5, 1, 2, 2, 3, 3]
  #
  #   a.insert(1, 5, axis:1)
  #   # => Numo::Int32#shape=[3,3]
  #   # [[1, 5, 1],
  #   #  [2, 5, 2],
  #   #  [3, 5, 3]]
  #
  #   a.insert([1], [[11],[12],[13]], axis:1)
  #   # => Numo::Int32#shape=[3,3]
  #   # [[1, 11, 1],
  #   #  [2, 12, 2],
  #   #  [3, 13, 3]]
  #
  #   a.insert(1, [11, 12, 13], axis:1)
  #   # => Numo::Int32#shape=[3,3]
  #   # [[1, 11, 1],
  #   #  [2, 12, 2],
  #   #  [3, 13, 3]]
  #
  #   a.insert([1], [11, 12, 13], axis:1)
  #   # => Numo::Int32#shape=[3,5]
  #   # [[1, 11, 12, 13, 1],
  #   #  [2, 11, 12, 13, 2],
  #   #  [3, 11, 12, 13, 3]]
  #
  #   b = a.flatten
  #   # => Numo::Int32(view)#shape=[6]
  #   # [1, 1, 2, 2, 3, 3]
  #
  #   b.insert(2,[15,16])
  #   # => Numo::Int32#shape=[8]
  #   # [1, 1, 15, 16, 2, 2, 3, 3]
  #
  #   b.insert([2,2],[15,16])
  #   # => Numo::Int32#shape=[8]
  #   # [1, 1, 15, 16, 2, 2, 3, 3]
  #
  #   b.insert([2,1],[15,16])
  #   # => Numo::Int32#shape=[8]
  #   # [1, 16, 1, 15, 2, 2, 3, 3]
  #
  #   b.insert([2,0,1],[15,16,17])
  #   # => Numo::Int32#shape=[9]
  #   # [16, 1, 17, 1, 15, 2, 2, 3, 3]
  #
  #   b.insert(2..3, [15, 16])
  #   # => Numo::Int32#shape=[8]
  #   # [1, 1, 15, 2, 16, 2, 3, 3]
  #
  #   b.insert(2, [7.13, 0.5])
  #   # => Numo::Int32#shape=[8]
  #   # [1, 1, 7, 0, 2, 2, 3, 3]
  #
  #   x = Numo::DFloat.new(2,4).seq
  #   # => Numo::DFloat#shape=[2,4]
  #   # [[0, 1, 2, 3],
  #   #  [4, 5, 6, 7]]
  #
  #   x.insert([1,3],999,axis:1)
  #   # => Numo::DFloat#shape=[2,6]
  #   # [[0, 999, 1, 2, 999, 3],
  #   #  [4, 999, 5, 6, 999, 7]]
  #
  # source://numo-narray//lib/numo/narray/extra.rb#360
  def insert(indice, values, axis: T.unsafe(nil)); end

  # Kronecker product of two arrays.
  #
  #     kron(a,b)[k_0, k_1, ...] = a[i_0, i_1, ...] * b[j_0, j_1, ...]
  #        where:  k_n = i_n * b.shape[n] + j_n
  #
  # @example
  #   Numo::DFloat[1,10,100].kron([5,6,7])
  #   # => Numo::DFloat#shape=[9]
  #   # [5, 6, 7, 50, 60, 70, 500, 600, 700]
  #
  #   Numo::DFloat[5,6,7].kron([1,10,100])
  #   # => Numo::DFloat#shape=[9]
  #   # [5, 50, 500, 6, 60, 600, 7, 70, 700]
  #
  #   Numo::DFloat.eye(2).kron(Numo::DFloat.ones(2,2))
  #   # => Numo::DFloat#shape=[4,4]
  #   # [[1, 1, 0, 0],
  #   #  [1, 1, 0, 0],
  #   #  [0, 0, 1, 1],
  #   #  [0, 0, 1, 1]]
  # @param b [Numo::NArray]
  # @return [Numo::NArray] return Kronecker product
  #
  # source://numo-narray//lib/numo/narray/extra.rb#1238
  def kron(b); end

  def length; end
  def little_endian?; end
  def marshal_dump; end
  def marshal_load(_arg0); end
  def ndim; end
  def network_order?; end

  # Return an array filled with value with the same shape and type as self.
  #
  # source://numo-narray//lib/numo/narray/extra.rb#20
  def new_fill(value); end

  # Return an unallocated array with the same shape and type as self.
  #
  # source://numo-narray//lib/numo/narray/extra.rb#5
  def new_narray; end

  # Return an array of ones with the same shape and type as self.
  #
  # source://numo-narray//lib/numo/narray/extra.rb#15
  def new_ones; end

  # Return an array of zeros with the same shape and type as self.
  #
  # source://numo-narray//lib/numo/narray/extra.rb#10
  def new_zeros; end

  def not_inplace!; end
  def out_of_place!; end

  # Outer product of two arrays.
  # Same as `self[false,:new] * b[false,:new,true]`.
  #
  # @example
  #   a = Numo::DFloat.ones(5)
  #   # => Numo::DFloat#shape=[5]
  #   # [1, 1, 1, 1, 1]
  #
  #   b = Numo::DFloat.linspace(-2,2,5)
  #   # => Numo::DFloat#shape=[5]
  #   # [-2, -1, 0, 1, 2]
  #
  #   a.outer(b)
  #   # => Numo::DFloat#shape=[5,5]
  #   # [[-2, -1, 0, 1, 2],
  #   #  [-2, -1, 0, 1, 2],
  #   #  [-2, -1, 0, 1, 2],
  #   #  [-2, -1, 0, 1, 2],
  #   #  [-2, -1, 0, 1, 2]]
  # @param b [Numo::NArray]
  # @param axis [Integer] applied axis (default=-1)
  # @return [Numo::NArray] return outer product
  #
  # source://numo-narray//lib/numo/narray/extra.rb#1168
  def outer(b, axis: T.unsafe(nil)); end

  # Percentile
  #
  # @param q [Numo::NArray]
  # @param axis [Integer] applied axis
  # @raise [ArgumentError]
  # @return [Numo::NArray] return percentile
  #
  # source://numo-narray//lib/numo/narray/extra.rb#1191
  def percentile(q, axis: T.unsafe(nil)); end

  # Convert angles from radians to degrees.
  #
  # source://numo-narray//lib/numo/narray/extra.rb#25
  def rad2deg; end

  def rank; end

  # @example
  #   Numo::NArray[3].repeat(4)
  #   # => Numo::Int32#shape=[4]
  #   # [3, 3, 3, 3]
  #
  #   x = Numo::NArray[[1,2],[3,4]]
  #   # => Numo::Int32#shape=[2,2]
  #   # [[1, 2],
  #   #  [3, 4]]
  #
  #   x.repeat(2)
  #   # => Numo::Int32#shape=[8]
  #   # [1, 1, 2, 2, 3, 3, 4, 4]
  #
  #   x.repeat(3,axis:1)
  #   # => Numo::Int32#shape=[2,6]
  #   # [[1, 1, 1, 2, 2, 2],
  #   #  [3, 3, 3, 4, 4, 4]]
  #
  #   x.repeat([1,2],axis:0)
  #   # => Numo::Int32#shape=[3,2]
  #   # [[1, 2],
  #   #  [3, 4],
  #   #  [3, 4]]
  #
  # source://numo-narray//lib/numo/narray/extra.rb#889
  def repeat(arg, axis: T.unsafe(nil)); end

  def reshape(*_arg0); end
  def reshape!(*_arg0); end
  def reverse(*_arg0); end

  # Rotate in the plane specified by axes.
  #
  # @example
  #   a = Numo::Int32.new(2,2).seq
  #   # => Numo::Int32#shape=[2,2]
  #   # [[0, 1],
  #   #  [2, 3]]
  #
  #   a.rot90
  #   # => Numo::Int32(view)#shape=[2,2]
  #   # [[1, 3],
  #   #  [0, 2]]
  #
  #   a.rot90(2)
  #   # => Numo::Int32(view)#shape=[2,2]
  #   # [[3, 2],
  #   #  [1, 0]]
  #
  #   a.rot90(3)
  #   # => Numo::Int32(view)#shape=[2,2]
  #   # [[2, 0],
  #   #  [3, 1]]
  #
  # source://numo-narray//lib/numo/narray/extra.rb#67
  def rot90(k = T.unsafe(nil), axes = T.unsafe(nil)); end

  def row_major?; end
  def shape; end
  def size; end
  def slice(*_arg0); end

  # @example
  #   x = Numo::DFloat.new(9).seq
  #   # => Numo::DFloat#shape=[9]
  #   # [0, 1, 2, 3, 4, 5, 6, 7, 8]
  #
  #   x.split(3)
  #   # => [Numo::DFloat(view)#shape=[3]
  #   # [0, 1, 2],
  #   #  Numo::DFloat(view)#shape=[3]
  #   # [3, 4, 5],
  #   #  Numo::DFloat(view)#shape=[3]
  #   # [6, 7, 8]]
  #
  #   x = Numo::DFloat.new(8).seq
  #   # => Numo::DFloat#shape=[8]
  #   # [0, 1, 2, 3, 4, 5, 6, 7]
  #
  #   x.split([3, 5, 6, 10])
  #   # => [Numo::DFloat(view)#shape=[3]
  #   # [0, 1, 2],
  #   #  Numo::DFloat(view)#shape=[2]
  #   # [3, 4],
  #   #  Numo::DFloat(view)#shape=[1]
  #   # [5],
  #   #  Numo::DFloat(view)#shape=[2]
  #   # [6, 7],
  #   #  Numo::DFloat(view)#shape=[0][]]
  #
  # source://numo-narray//lib/numo/narray/extra.rb#700
  def split(indices_or_sections, axis: T.unsafe(nil)); end

  def store_binary(*_arg0); end
  def swap_byte; end
  def swapaxes(_arg0, _arg1); end

  # @example
  #   a = Numo::NArray[0,1,2]
  #   # => Numo::Int32#shape=[3]
  #   # [0, 1, 2]
  #
  #   a.tile(2)
  #   # => Numo::Int32#shape=[6]
  #   # [0, 1, 2, 0, 1, 2]
  #
  #   a.tile(2,2)
  #   # => Numo::Int32#shape=[2,6]
  #   # [[0, 1, 2, 0, 1, 2],
  #   #  [0, 1, 2, 0, 1, 2]]
  #
  #   a.tile(2,1,2)
  #   # => Numo::Int32#shape=[2,1,6]
  #   # [[[0, 1, 2, 0, 1, 2]],
  #   #  [[0, 1, 2, 0, 1, 2]]]
  #
  #   b = Numo::NArray[[1, 2], [3, 4]]
  #   # => Numo::Int32#shape=[2,2]
  #   # [[1, 2],
  #   #  [3, 4]]
  #
  #   b.tile(2)
  #   # => Numo::Int32#shape=[2,4]
  #   # [[1, 2, 1, 2],
  #   #  [3, 4, 3, 4]]
  #
  #   b.tile(2,1)
  #   # => Numo::Int32#shape=[4,2]
  #   # [[1, 2],
  #   #  [3, 4],
  #   #  [1, 2],
  #   #  [3, 4]]
  #
  #   c = Numo::NArray[1,2,3,4]
  #   # => Numo::Int32#shape=[4]
  #   # [1, 2, 3, 4]
  #
  #   c.tile(4,1)
  #   # => Numo::Int32#shape=[4,4]
  #   # [[1, 2, 3, 4],
  #   #  [1, 2, 3, 4],
  #   #  [1, 2, 3, 4],
  #   #  [1, 2, 3, 4]]
  #
  # source://numo-narray//lib/numo/narray/extra.rb#828
  def tile(*arg); end

  def to_binary; end

  # source://numo-narray//lib/numo/narray/extra.rb#98
  def to_c; end

  # source://numo-narray//lib/numo/narray/extra.rb#89
  def to_f; end

  def to_host; end

  # source://numo-narray//lib/numo/narray/extra.rb#80
  def to_i; end

  def to_network; end
  def to_string; end
  def to_swapped; end
  def to_vacs; end
  def total; end

  # Return the sum along diagonals of the array.
  #
  # If 2-D array, computes the summation along its diagonal with the
  # given offset, i.e., sum of `a[i,i+offset]`.
  # If more than 2-D array, the diagonal is determined from the axes
  # specified by axis argument. The default is axis=[-2,-1].
  #
  # @param offset [Integer] (optional, default=0) diagonal offset
  # @param axis [Array] (optional, default=[-2,-1]) diagonal axis
  # @param nan [Bool] (optional, default=false) nan-aware algorithm, i.e., if true then it ignores nan.
  #
  # source://numo-narray//lib/numo/narray/extra.rb#1091
  def trace(offset = T.unsafe(nil), axis = T.unsafe(nil), nan: T.unsafe(nil)); end

  def transpose(*_arg0); end

  # Lower triangular matrix.
  # Return a copy with the elements above the k-th diagonal filled with zero.
  #
  # source://numo-narray//lib/numo/narray/extra.rb#1019
  def tril(k = T.unsafe(nil)); end

  # Lower triangular matrix.
  # Fill the self elements above the k-th diagonal with zero.
  #
  # source://numo-narray//lib/numo/narray/extra.rb#1025
  def tril!(k = T.unsafe(nil)); end

  # Return the indices for the lower-triangle on and below the k-th diagonal.
  #
  # source://numo-narray//lib/numo/narray/extra.rb#1041
  def tril_indices(k = T.unsafe(nil)); end

  # Upper triangular matrix.
  # Return a copy with the elements below the k-th diagonal filled with zero.
  #
  # source://numo-narray//lib/numo/narray/extra.rb#980
  def triu(k = T.unsafe(nil)); end

  # Upper triangular matrix.
  # Fill the self elements below the k-th diagonal with zero.
  #
  # source://numo-narray//lib/numo/narray/extra.rb#986
  def triu!(k = T.unsafe(nil)); end

  # Return the indices for the uppler-triangle on and above the k-th diagonal.
  #
  # source://numo-narray//lib/numo/narray/extra.rb#1002
  def triu_indices(k = T.unsafe(nil)); end

  def vacs_order?; end
  def view; end

  # @example
  #   x = Numo::DFloat.new(4,4).seq
  #   # => Numo::DFloat#shape=[4,4]
  #   # [[0, 1, 2, 3],
  #   #  [4, 5, 6, 7],
  #   #  [8, 9, 10, 11],
  #   #  [12, 13, 14, 15]]
  #
  #   x.hsplit(2)
  #   # => [Numo::DFloat(view)#shape=[4,2]
  #   # [[0, 1],
  #   #  [4, 5],
  #   #  [8, 9],
  #   #  [12, 13]],
  #   #  Numo::DFloat(view)#shape=[4,2]
  #   # [[2, 3],
  #   #  [6, 7],
  #   #  [10, 11],
  #   #  [14, 15]]]
  #
  #   x.hsplit([3, 6])
  #   # => [Numo::DFloat(view)#shape=[4,3]
  #   # [[0, 1, 2],
  #   #  [4, 5, 6],
  #   #  [8, 9, 10],
  #   #  [12, 13, 14]],
  #   #  Numo::DFloat(view)#shape=[4,1]
  #   # [[3],
  #   #  [7],
  #   #  [11],
  #   #  [15]],
  #   #  Numo::DFloat(view)#shape=[4,0][]]
  #
  # source://numo-narray//lib/numo/narray/extra.rb#769
  def vsplit(indices_or_sections); end

  private

  # source://numo-narray//lib/numo/narray/extra.rb#1297
  def check_axis(axis); end

  def initialize_copy(_arg0); end

  class << self
    def [](*_arg0); end
    def array_shape(_arg0); end
    def array_type(_arg0); end

    # source://numo-narray//lib/numo/narray/extra.rb#124
    def asarray(a); end

    def byte_size; end

    # Convert the argument to an narray if not an narray.
    #
    # source://numo-narray//lib/numo/narray/extra.rb#108
    def cast(a); end

    # Stack 1-d arrays into columns of a 2-d array.
    #
    # @example
    #   x = Numo::Int32[1,2,3]
    #   y = Numo::Int32[2,3,4]
    #   Numo::NArray.column_stack([x,y])
    #   # => Numo::Int32#shape=[3,2]
    #   # [[1, 2],
    #   #  [2, 3],
    #   #  [3, 4]]
    #
    # source://numo-narray//lib/numo/narray/extra.rb#572
    def column_stack(arrays); end

    # @example
    #   a = Numo::DFloat[[1, 2], [3, 4]]
    #   # => Numo::DFloat#shape=[2,2]
    #   # [[1, 2],
    #   #  [3, 4]]
    #
    #   b = Numo::DFloat[[5, 6]]
    #   # => Numo::DFloat#shape=[1,2]
    #   # [[5, 6]]
    #
    #   Numo::NArray.concatenate([a,b],axis:0)
    #   # => Numo::DFloat#shape=[3,2]
    #   # [[1, 2],
    #   #  [3, 4],
    #   #  [5, 6]]
    #
    #   Numo::NArray.concatenate([a,b.transpose], axis:1)
    #   # => Numo::DFloat#shape=[2,3]
    #   # [[1, 2, 5],
    #   #  [3, 4, 6]]
    #
    # source://numo-narray//lib/numo/narray/extra.rb#426
    def concatenate(arrays, axis: T.unsafe(nil)); end

    def debug=(_arg0); end

    # Return the k-th diagonal indices.
    #
    # source://numo-narray//lib/numo/narray/extra.rb#1066
    def diag_indices(m, n, k = T.unsafe(nil)); end

    # Stack arrays in depth wise (along third axis).
    #
    # @example
    #   a = Numo::Int32[1,2,3]
    #   b = Numo::Int32[2,3,4]
    #   Numo::NArray.dstack([a,b])
    #   # => Numo::Int32#shape=[1,3,2]
    #   # [[[1, 2],
    #   #   [2, 3],
    #   #   [3, 4]]]
    #
    #   a = Numo::Int32[[1],[2],[3]]
    #   b = Numo::Int32[[2],[3],[4]]
    #   Numo::NArray.dstack([a,b])
    #   # => Numo::Int32#shape=[3,1,2]
    #   # [[[1, 2]],
    #   #  [[2, 3]],
    #   #  [[3, 4]]]
    #
    # source://numo-narray//lib/numo/narray/extra.rb#555
    def dstack(arrays); end

    def eye(*_arg0); end
    def from_binary(*_arg0); end
    def from_string(*_arg0); end

    # Stack arrays horizontally (column wise).
    #
    # @example
    #   a = Numo::Int32[1,2,3]
    #   b = Numo::Int32[2,3,4]
    #   Numo::NArray.hstack([a,b])
    #   # => Numo::Int32#shape=[6]
    #   # [1, 2, 3, 2, 3, 4]
    #
    #   a = Numo::Int32[[1],[2],[3]]
    #   b = Numo::Int32[[2],[3],[4]]
    #   Numo::NArray.hstack([a,b])
    #   # => Numo::Int32#shape=[3,2]
    #   # [[1, 2],
    #   #  [2, 3],
    #   #  [3, 4]]
    #
    # source://numo-narray//lib/numo/narray/extra.rb#525
    def hstack(arrays); end

    def inspect_cols; end
    def inspect_cols=(_arg0); end
    def inspect_rows; end
    def inspect_rows=(_arg0); end
    def linspace(*_arg0); end
    def logspace(*_arg0); end
    def new_like(_arg0); end
    def ones(*_arg0); end

    # parse matrix like matlab, octave
    #
    # @example
    #   a = Numo::DFloat.parse %[
    #   2 -3 5
    #   4 9 7
    #   2 -1 6
    #   ]
    #   # => Numo::DFloat#shape=[3,3]
    #   # [[2, -3, 5],
    #   #  [4, 9, 7],
    #   #  [2, -1, 6]]
    #
    # source://numo-narray//lib/numo/narray/extra.rb#147
    def parse(str, split1d: T.unsafe(nil), split2d: T.unsafe(nil), split3d: T.unsafe(nil)); end

    def profile; end
    def profile=(_arg0); end
    def srand(*_arg0); end

    # Return the indices for the lower-triangle on and below the k-th diagonal.
    #
    # source://numo-narray//lib/numo/narray/extra.rb#1050
    def tril_indices(m, n, k = T.unsafe(nil)); end

    # Return the indices for the uppler-triangle on and above the k-th diagonal.
    #
    # source://numo-narray//lib/numo/narray/extra.rb#1011
    def triu_indices(m, n, k = T.unsafe(nil)); end

    def upcast(_arg0); end

    # Stack arrays vertically (row wise).
    #
    # @example
    #   a = Numo::Int32[1,2,3]
    #   b = Numo::Int32[2,3,4]
    #   Numo::NArray.vstack([a,b])
    #   # => Numo::Int32#shape=[2,3]
    #   # [[1, 2, 3],
    #   #  [2, 3, 4]]
    #
    #   a = Numo::Int32[[1],[2],[3]]
    #   b = Numo::Int32[[2],[3],[4]]
    #   Numo::NArray.vstack([a,b])
    #   # => Numo::Int32#shape=[6,1]
    #   # [[1],
    #   #  [2],
    #   #  [3],
    #   #  [2],
    #   #  [3],
    #   #  [4]]
    #
    # source://numo-narray//lib/numo/narray/extra.rb#502
    def vstack(arrays); end

    def zeros(*_arg0); end

    private

    # Return an narray with at least two dimension.
    #
    # source://numo-narray//lib/numo/narray/extra.rb#586
    def _atleast_2d(a); end

    # Return an narray with at least three dimension.
    #
    # source://numo-narray//lib/numo/narray/extra.rb#595
    def _atleast_3d(a); end
  end
end

class Numo::NArray::CastError < ::StandardError; end
class Numo::NArray::DimensionError < ::StandardError; end
class Numo::NArray::OperationError < ::StandardError; end
class Numo::NArray::ShapeError < ::StandardError; end
Numo::NArray::VERSION = T.let(T.unsafe(nil), String)
class Numo::NArray::ValueError < ::StandardError; end

module Numo::NMath
  class << self
    def method_missing(*_arg0); end
  end
end

Numo::NMath::DISPATCH = T.let(T.unsafe(nil), Hash)

class Numo::RObject < ::Numo::NArray
  def %(_arg0); end
  def &(_arg0); end
  def *(_arg0); end
  def **(_arg0); end
  def +(_arg0); end
  def -(_arg0); end
  def -@; end
  def /(_arg0); end
  def <(_arg0); end
  def <<(_arg0); end
  def <=(_arg0); end
  def >(_arg0); end
  def >=(_arg0); end
  def >>(_arg0); end
  def [](*_arg0); end
  def []=(*_arg0); end
  def ^(_arg0); end
  def abs; end
  def allocate; end
  def argmax(*_arg0); end
  def argmin(*_arg0); end
  def ceil; end
  def clip(_arg0, _arg1); end
  def close_to(_arg0); end
  def coerce_cast(_arg0); end
  def conj; end
  def conjugate; end
  def cumprod(*_arg0); end
  def cumsum(*_arg0); end
  def divmod(_arg0); end
  def each; end
  def each_with_index; end
  def eq(_arg0); end
  def extract; end
  def eye(*_arg0); end
  def fill(_arg0); end
  def floor; end
  def format(*_arg0); end
  def format_to_a(*_arg0); end
  def ge(_arg0); end
  def gt(_arg0); end
  def im; end
  def indgen(*_arg0); end
  def inspect; end
  def isfinite; end
  def isinf; end
  def isnan; end
  def isneginf; end
  def isposinf; end
  def le(_arg0); end
  def logseq(*_arg0); end
  def lt(_arg0); end
  def map; end
  def map_with_index; end
  def max(*_arg0); end
  def max_index(*_arg0); end
  def mean(*_arg0); end
  def min(*_arg0); end
  def min_index(*_arg0); end
  def minmax(*_arg0); end
  def mulsum(*_arg0); end
  def ne(_arg0); end
  def nearly_eq(_arg0); end
  def poly(*_arg0); end
  def pow(_arg0); end
  def prod(*_arg0); end
  def ptp(*_arg0); end
  def rand(*_arg0); end
  def reciprocal; end
  def rms(*_arg0); end
  def round; end
  def seq(*_arg0); end
  def sign; end
  def square; end
  def stddev(*_arg0); end
  def store(_arg0); end
  def sum(*_arg0); end
  def to_a; end
  def trunc; end
  def var(*_arg0); end
  def |(_arg0); end
  def ~; end

  private

  def maximum(*_arg0); end
  def minimum(*_arg0); end

  class << self
    def [](*_arg0); end
    def cast(_arg0); end
    def maximum(*_arg0); end
    def minimum(*_arg0); end
  end
end

Numo::RObject::CONTIGUOUS_STRIDE = T.let(T.unsafe(nil), Integer)
Numo::RObject::ELEMENT_BIT_SIZE = T.let(T.unsafe(nil), Integer)
Numo::RObject::ELEMENT_BYTE_SIZE = T.let(T.unsafe(nil), Integer)
Numo::RObject::UPCAST = T.let(T.unsafe(nil), Hash)

class Numo::SComplex < ::Numo::NArray
  def *(_arg0); end
  def **(_arg0); end
  def +(_arg0); end
  def -(_arg0); end
  def -@; end
  def /(_arg0); end
  def [](*_arg0); end
  def []=(*_arg0); end
  def abs; end
  def allocate; end
  def angle; end
  def arg; end
  def ceil; end
  def close_to(_arg0); end
  def coerce_cast(_arg0); end
  def conj; end
  def conjugate; end
  def copysign(_arg0); end
  def cumprod(*_arg0); end
  def cumsum(*_arg0); end
  def each; end
  def each_with_index; end
  def eq(_arg0); end
  def extract; end
  def eye(*_arg0); end
  def fill(_arg0); end
  def floor; end
  def format(*_arg0); end
  def format_to_a(*_arg0); end
  def im; end
  def imag; end
  def imag=(_arg0); end
  def indgen(*_arg0); end
  def inspect; end
  def isfinite; end
  def isinf; end
  def isnan; end
  def isneginf; end
  def isposinf; end
  def logseq(*_arg0); end
  def map; end
  def map_with_index; end
  def mean(*_arg0); end
  def mulsum(*_arg0); end
  def ne(_arg0); end
  def nearly_eq(_arg0); end
  def poly(*_arg0); end
  def pow(_arg0); end
  def prod(*_arg0); end
  def rand(*_arg0); end
  def rand_norm(*_arg0); end
  def real; end
  def real=(_arg0); end
  def reciprocal; end
  def rint; end
  def rms(*_arg0); end
  def round; end
  def seq(*_arg0); end
  def set_imag(_arg0); end
  def set_real(_arg0); end
  def sign; end
  def square; end
  def stddev(*_arg0); end
  def store(_arg0); end
  def sum(*_arg0); end
  def to_a; end
  def trunc; end
  def var(*_arg0); end

  class << self
    def [](*_arg0); end
    def cast(_arg0); end
  end
end

Numo::SComplex::CONTIGUOUS_STRIDE = T.let(T.unsafe(nil), Integer)
Numo::SComplex::ELEMENT_BIT_SIZE = T.let(T.unsafe(nil), Integer)
Numo::SComplex::ELEMENT_BYTE_SIZE = T.let(T.unsafe(nil), Integer)
Numo::SComplex::EPSILON = T.let(T.unsafe(nil), Float)
Numo::SComplex::MAX = T.let(T.unsafe(nil), Float)
Numo::SComplex::MIN = T.let(T.unsafe(nil), Float)

module Numo::SComplex::Math
  private

  def acos(_arg0); end
  def acosh(_arg0); end
  def asin(_arg0); end
  def asinh(_arg0); end
  def atan(_arg0); end
  def atanh(_arg0); end
  def cbrt(_arg0); end
  def cos(_arg0); end
  def cosh(_arg0); end
  def exp(_arg0); end
  def exp10(_arg0); end
  def exp2(_arg0); end
  def log(_arg0); end
  def log10(_arg0); end
  def log2(_arg0); end
  def sin(_arg0); end
  def sinc(_arg0); end
  def sinh(_arg0); end
  def sqrt(_arg0); end
  def tan(_arg0); end
  def tanh(_arg0); end

  class << self
    def acos(_arg0); end
    def acosh(_arg0); end
    def asin(_arg0); end
    def asinh(_arg0); end
    def atan(_arg0); end
    def atanh(_arg0); end
    def cbrt(_arg0); end
    def cos(_arg0); end
    def cosh(_arg0); end
    def exp(_arg0); end
    def exp10(_arg0); end
    def exp2(_arg0); end
    def log(_arg0); end
    def log10(_arg0); end
    def log2(_arg0); end
    def sin(_arg0); end
    def sinc(_arg0); end
    def sinh(_arg0); end
    def sqrt(_arg0); end
    def tan(_arg0); end
    def tanh(_arg0); end
  end
end

Numo::SComplex::UPCAST = T.let(T.unsafe(nil), Hash)

class Numo::SFloat < ::Numo::NArray
  def %(_arg0); end
  def *(_arg0); end
  def **(_arg0); end
  def +(_arg0); end
  def -(_arg0); end
  def -@; end
  def /(_arg0); end
  def <(_arg0); end
  def <=(_arg0); end
  def >(_arg0); end
  def >=(_arg0); end
  def [](*_arg0); end
  def []=(*_arg0); end
  def abs; end
  def allocate; end
  def argmax(*_arg0); end
  def argmin(*_arg0); end
  def ceil; end
  def clip(_arg0, _arg1); end
  def close_to(_arg0); end
  def coerce_cast(_arg0); end
  def conj; end
  def conjugate; end
  def copysign(_arg0); end
  def cumprod(*_arg0); end
  def cumsum(*_arg0); end
  def divmod(_arg0); end
  def each; end
  def each_with_index; end
  def eq(_arg0); end
  def extract; end
  def eye(*_arg0); end
  def fill(_arg0); end
  def floor; end
  def format(*_arg0); end
  def format_to_a(*_arg0); end
  def ge(_arg0); end
  def gt(_arg0); end
  def im; end
  def indgen(*_arg0); end
  def inspect; end
  def isfinite; end
  def isinf; end
  def isnan; end
  def isneginf; end
  def isposinf; end
  def le(_arg0); end
  def logseq(*_arg0); end
  def lt(_arg0); end
  def map; end
  def map_with_index; end
  def max(*_arg0); end
  def max_index(*_arg0); end
  def mean(*_arg0); end
  def median(*_arg0); end
  def min(*_arg0); end
  def min_index(*_arg0); end
  def minmax(*_arg0); end
  def modf; end
  def mulsum(*_arg0); end
  def ne(_arg0); end
  def nearly_eq(_arg0); end
  def poly(*_arg0); end
  def pow(_arg0); end
  def prod(*_arg0); end
  def ptp(*_arg0); end
  def rand(*_arg0); end
  def rand_norm(*_arg0); end
  def reciprocal; end
  def rint; end
  def rms(*_arg0); end
  def round; end
  def seq(*_arg0); end
  def sign; end
  def signbit; end
  def sort(*_arg0); end
  def sort_index(*_arg0); end
  def square; end
  def stddev(*_arg0); end
  def store(_arg0); end
  def sum(*_arg0); end
  def to_a; end
  def trunc; end
  def var(*_arg0); end

  private

  def maximum(*_arg0); end
  def minimum(*_arg0); end

  class << self
    def [](*_arg0); end
    def cast(_arg0); end
    def maximum(*_arg0); end
    def minimum(*_arg0); end
  end
end

Numo::SFloat::CONTIGUOUS_STRIDE = T.let(T.unsafe(nil), Integer)
Numo::SFloat::ELEMENT_BIT_SIZE = T.let(T.unsafe(nil), Integer)
Numo::SFloat::ELEMENT_BYTE_SIZE = T.let(T.unsafe(nil), Integer)
Numo::SFloat::EPSILON = T.let(T.unsafe(nil), Float)
Numo::SFloat::MAX = T.let(T.unsafe(nil), Float)
Numo::SFloat::MIN = T.let(T.unsafe(nil), Float)

module Numo::SFloat::Math
  private

  def acos(_arg0); end
  def acosh(_arg0); end
  def asin(_arg0); end
  def asinh(_arg0); end
  def atan(_arg0); end
  def atan2(_arg0, _arg1); end
  def atanh(_arg0); end
  def cbrt(_arg0); end
  def cos(_arg0); end
  def cosh(_arg0); end
  def erf(_arg0); end
  def erfc(_arg0); end
  def exp(_arg0); end
  def exp10(_arg0); end
  def exp2(_arg0); end
  def expm1(_arg0); end
  def frexp(_arg0); end
  def hypot(_arg0, _arg1); end
  def ldexp(_arg0, _arg1); end
  def log(_arg0); end
  def log10(_arg0); end
  def log1p(_arg0); end
  def log2(_arg0); end
  def sin(_arg0); end
  def sinc(_arg0); end
  def sinh(_arg0); end
  def sqrt(_arg0); end
  def tan(_arg0); end
  def tanh(_arg0); end

  class << self
    def acos(_arg0); end
    def acosh(_arg0); end
    def asin(_arg0); end
    def asinh(_arg0); end
    def atan(_arg0); end
    def atan2(_arg0, _arg1); end
    def atanh(_arg0); end
    def cbrt(_arg0); end
    def cos(_arg0); end
    def cosh(_arg0); end
    def erf(_arg0); end
    def erfc(_arg0); end
    def exp(_arg0); end
    def exp10(_arg0); end
    def exp2(_arg0); end
    def expm1(_arg0); end
    def frexp(_arg0); end
    def hypot(_arg0, _arg1); end
    def ldexp(_arg0, _arg1); end
    def log(_arg0); end
    def log10(_arg0); end
    def log1p(_arg0); end
    def log2(_arg0); end
    def sin(_arg0); end
    def sinc(_arg0); end
    def sinh(_arg0); end
    def sqrt(_arg0); end
    def tan(_arg0); end
    def tanh(_arg0); end
  end
end

Numo::SFloat::UPCAST = T.let(T.unsafe(nil), Hash)

class Numo::Struct < ::Numo::NArray
  def definition(_arg0); end
  def definitions; end
  def extract; end
  def field(_arg0); end
  def field_set(_arg0, _arg1); end
  def inspect; end
  def method_missing(*_arg0); end
  def store(_arg0); end
  def to_a; end

  class << self
    def [](*_arg0); end
    def add_type(*_arg0); end
    def cast(_arg0); end
    def complex128(*_arg0); end
    def complex64(*_arg0); end
    def dcomplex(*_arg0); end
    def dfloat(*_arg0); end
    def float32(*_arg0); end
    def float64(*_arg0); end
    def int16(*_arg0); end
    def int32(*_arg0); end
    def int64(*_arg0); end
    def int8(*_arg0); end
    def new(*_arg0); end
    def scomplex(*_arg0); end
    def sfloat(*_arg0); end
    def uint16(*_arg0); end
    def uint32(*_arg0); end
    def uint64(*_arg0); end
    def uint8(*_arg0); end
  end
end

class Numo::UInt16 < ::Numo::NArray
  def %(_arg0); end
  def &(_arg0); end
  def *(_arg0); end
  def **(_arg0); end
  def +(_arg0); end
  def -(_arg0); end
  def -@; end
  def /(_arg0); end
  def <(_arg0); end
  def <<(_arg0); end
  def <=(_arg0); end
  def >(_arg0); end
  def >=(_arg0); end
  def >>(_arg0); end
  def [](*_arg0); end
  def []=(*_arg0); end
  def ^(_arg0); end
  def abs; end
  def allocate; end
  def argmax(*_arg0); end
  def argmin(*_arg0); end
  def bincount(*_arg0); end
  def ceil; end
  def clip(_arg0, _arg1); end
  def close_to(_arg0); end
  def coerce_cast(_arg0); end
  def conj; end
  def conjugate; end
  def cumprod(*_arg0); end
  def cumsum(*_arg0); end
  def divmod(_arg0); end
  def each; end
  def each_with_index; end
  def eq(_arg0); end
  def extract; end
  def eye(*_arg0); end
  def fill(_arg0); end
  def floor; end
  def format(*_arg0); end
  def format_to_a(*_arg0); end
  def ge(_arg0); end
  def gt(_arg0); end
  def im; end
  def indgen(*_arg0); end
  def inspect; end
  def le(_arg0); end
  def lt(_arg0); end
  def map; end
  def map_with_index; end
  def max(*_arg0); end
  def max_index(*_arg0); end
  def median(*_arg0); end
  def min(*_arg0); end
  def min_index(*_arg0); end
  def minmax(*_arg0); end
  def mulsum(*_arg0); end
  def ne(_arg0); end
  def nearly_eq(_arg0); end
  def poly(*_arg0); end
  def pow(_arg0); end
  def prod(*_arg0); end
  def ptp(*_arg0); end
  def rand(*_arg0); end
  def reciprocal; end
  def rint; end
  def round; end
  def seq(*_arg0); end
  def sign; end
  def sort(*_arg0); end
  def sort_index(*_arg0); end
  def square; end
  def store(_arg0); end
  def sum(*_arg0); end
  def to_a; end
  def trunc; end
  def |(_arg0); end
  def ~; end

  private

  def maximum(*_arg0); end
  def minimum(*_arg0); end

  class << self
    def [](*_arg0); end
    def cast(_arg0); end
    def maximum(*_arg0); end
    def minimum(*_arg0); end
  end
end

Numo::UInt16::CONTIGUOUS_STRIDE = T.let(T.unsafe(nil), Integer)
Numo::UInt16::ELEMENT_BIT_SIZE = T.let(T.unsafe(nil), Integer)
Numo::UInt16::ELEMENT_BYTE_SIZE = T.let(T.unsafe(nil), Integer)
Numo::UInt16::MAX = T.let(T.unsafe(nil), Integer)
Numo::UInt16::MIN = T.let(T.unsafe(nil), Integer)
Numo::UInt16::UPCAST = T.let(T.unsafe(nil), Hash)

class Numo::UInt32 < ::Numo::NArray
  def %(_arg0); end
  def &(_arg0); end
  def *(_arg0); end
  def **(_arg0); end
  def +(_arg0); end
  def -(_arg0); end
  def -@; end
  def /(_arg0); end
  def <(_arg0); end
  def <<(_arg0); end
  def <=(_arg0); end
  def >(_arg0); end
  def >=(_arg0); end
  def >>(_arg0); end
  def [](*_arg0); end
  def []=(*_arg0); end
  def ^(_arg0); end
  def abs; end
  def allocate; end
  def argmax(*_arg0); end
  def argmin(*_arg0); end
  def bincount(*_arg0); end
  def ceil; end
  def clip(_arg0, _arg1); end
  def close_to(_arg0); end
  def coerce_cast(_arg0); end
  def conj; end
  def conjugate; end
  def cumprod(*_arg0); end
  def cumsum(*_arg0); end
  def divmod(_arg0); end
  def each; end
  def each_with_index; end
  def eq(_arg0); end
  def extract; end
  def eye(*_arg0); end
  def fill(_arg0); end
  def floor; end
  def format(*_arg0); end
  def format_to_a(*_arg0); end
  def ge(_arg0); end
  def gt(_arg0); end
  def im; end
  def indgen(*_arg0); end
  def inspect; end
  def le(_arg0); end
  def lt(_arg0); end
  def map; end
  def map_with_index; end
  def max(*_arg0); end
  def max_index(*_arg0); end
  def median(*_arg0); end
  def min(*_arg0); end
  def min_index(*_arg0); end
  def minmax(*_arg0); end
  def mulsum(*_arg0); end
  def ne(_arg0); end
  def nearly_eq(_arg0); end
  def poly(*_arg0); end
  def pow(_arg0); end
  def prod(*_arg0); end
  def ptp(*_arg0); end
  def rand(*_arg0); end
  def reciprocal; end
  def rint; end
  def round; end
  def seq(*_arg0); end
  def sign; end
  def sort(*_arg0); end
  def sort_index(*_arg0); end
  def square; end
  def store(_arg0); end
  def sum(*_arg0); end
  def to_a; end
  def trunc; end
  def |(_arg0); end
  def ~; end

  private

  def maximum(*_arg0); end
  def minimum(*_arg0); end

  class << self
    def [](*_arg0); end
    def cast(_arg0); end
    def maximum(*_arg0); end
    def minimum(*_arg0); end
  end
end

Numo::UInt32::CONTIGUOUS_STRIDE = T.let(T.unsafe(nil), Integer)
Numo::UInt32::ELEMENT_BIT_SIZE = T.let(T.unsafe(nil), Integer)
Numo::UInt32::ELEMENT_BYTE_SIZE = T.let(T.unsafe(nil), Integer)
Numo::UInt32::MAX = T.let(T.unsafe(nil), Integer)
Numo::UInt32::MIN = T.let(T.unsafe(nil), Integer)
Numo::UInt32::UPCAST = T.let(T.unsafe(nil), Hash)

class Numo::UInt64 < ::Numo::NArray
  def %(_arg0); end
  def &(_arg0); end
  def *(_arg0); end
  def **(_arg0); end
  def +(_arg0); end
  def -(_arg0); end
  def -@; end
  def /(_arg0); end
  def <(_arg0); end
  def <<(_arg0); end
  def <=(_arg0); end
  def >(_arg0); end
  def >=(_arg0); end
  def >>(_arg0); end
  def [](*_arg0); end
  def []=(*_arg0); end
  def ^(_arg0); end
  def abs; end
  def allocate; end
  def argmax(*_arg0); end
  def argmin(*_arg0); end
  def bincount(*_arg0); end
  def ceil; end
  def clip(_arg0, _arg1); end
  def close_to(_arg0); end
  def coerce_cast(_arg0); end
  def conj; end
  def conjugate; end
  def cumprod(*_arg0); end
  def cumsum(*_arg0); end
  def divmod(_arg0); end
  def each; end
  def each_with_index; end
  def eq(_arg0); end
  def extract; end
  def eye(*_arg0); end
  def fill(_arg0); end
  def floor; end
  def format(*_arg0); end
  def format_to_a(*_arg0); end
  def ge(_arg0); end
  def gt(_arg0); end
  def im; end
  def indgen(*_arg0); end
  def inspect; end
  def le(_arg0); end
  def lt(_arg0); end
  def map; end
  def map_with_index; end
  def max(*_arg0); end
  def max_index(*_arg0); end
  def median(*_arg0); end
  def min(*_arg0); end
  def min_index(*_arg0); end
  def minmax(*_arg0); end
  def mulsum(*_arg0); end
  def ne(_arg0); end
  def nearly_eq(_arg0); end
  def poly(*_arg0); end
  def pow(_arg0); end
  def prod(*_arg0); end
  def ptp(*_arg0); end
  def rand(*_arg0); end
  def reciprocal; end
  def rint; end
  def round; end
  def seq(*_arg0); end
  def sign; end
  def sort(*_arg0); end
  def sort_index(*_arg0); end
  def square; end
  def store(_arg0); end
  def sum(*_arg0); end
  def to_a; end
  def trunc; end
  def |(_arg0); end
  def ~; end

  private

  def maximum(*_arg0); end
  def minimum(*_arg0); end

  class << self
    def [](*_arg0); end
    def cast(_arg0); end
    def maximum(*_arg0); end
    def minimum(*_arg0); end
  end
end

Numo::UInt64::CONTIGUOUS_STRIDE = T.let(T.unsafe(nil), Integer)
Numo::UInt64::ELEMENT_BIT_SIZE = T.let(T.unsafe(nil), Integer)
Numo::UInt64::ELEMENT_BYTE_SIZE = T.let(T.unsafe(nil), Integer)
Numo::UInt64::MAX = T.let(T.unsafe(nil), Integer)
Numo::UInt64::MIN = T.let(T.unsafe(nil), Integer)
Numo::UInt64::UPCAST = T.let(T.unsafe(nil), Hash)

class Numo::UInt8 < ::Numo::NArray
  def %(_arg0); end
  def &(_arg0); end
  def *(_arg0); end
  def **(_arg0); end
  def +(_arg0); end
  def -(_arg0); end
  def -@; end
  def /(_arg0); end
  def <(_arg0); end
  def <<(_arg0); end
  def <=(_arg0); end
  def >(_arg0); end
  def >=(_arg0); end
  def >>(_arg0); end
  def [](*_arg0); end
  def []=(*_arg0); end
  def ^(_arg0); end
  def abs; end
  def allocate; end
  def argmax(*_arg0); end
  def argmin(*_arg0); end
  def bincount(*_arg0); end
  def ceil; end
  def clip(_arg0, _arg1); end
  def close_to(_arg0); end
  def coerce_cast(_arg0); end
  def conj; end
  def conjugate; end
  def cumprod(*_arg0); end
  def cumsum(*_arg0); end
  def divmod(_arg0); end
  def each; end
  def each_with_index; end
  def eq(_arg0); end
  def extract; end
  def eye(*_arg0); end
  def fill(_arg0); end
  def floor; end
  def format(*_arg0); end
  def format_to_a(*_arg0); end
  def ge(_arg0); end
  def gt(_arg0); end
  def im; end
  def indgen(*_arg0); end
  def inspect; end
  def le(_arg0); end
  def lt(_arg0); end
  def map; end
  def map_with_index; end
  def max(*_arg0); end
  def max_index(*_arg0); end
  def median(*_arg0); end
  def min(*_arg0); end
  def min_index(*_arg0); end
  def minmax(*_arg0); end
  def mulsum(*_arg0); end
  def ne(_arg0); end
  def nearly_eq(_arg0); end
  def poly(*_arg0); end
  def pow(_arg0); end
  def prod(*_arg0); end
  def ptp(*_arg0); end
  def rand(*_arg0); end
  def reciprocal; end
  def rint; end
  def round; end
  def seq(*_arg0); end
  def sign; end
  def sort(*_arg0); end
  def sort_index(*_arg0); end
  def square; end
  def store(_arg0); end
  def sum(*_arg0); end
  def to_a; end
  def trunc; end
  def |(_arg0); end
  def ~; end

  private

  def maximum(*_arg0); end
  def minimum(*_arg0); end

  class << self
    def [](*_arg0); end
    def cast(_arg0); end
    def maximum(*_arg0); end
    def minimum(*_arg0); end
  end
end

Numo::UInt8::CONTIGUOUS_STRIDE = T.let(T.unsafe(nil), Integer)
Numo::UInt8::ELEMENT_BIT_SIZE = T.let(T.unsafe(nil), Integer)
Numo::UInt8::ELEMENT_BYTE_SIZE = T.let(T.unsafe(nil), Integer)
Numo::UInt8::MAX = T.let(T.unsafe(nil), Integer)
Numo::UInt8::MIN = T.let(T.unsafe(nil), Integer)
Numo::UInt8::UPCAST = T.let(T.unsafe(nil), Hash)
